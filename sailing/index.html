<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Sailing Prototype - Level 0</title>

    <!-- PWA / iOS Standalone -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sailing">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Primary Meta Tags -->
    <meta name="title" content="Sailing Prototype - Level 0">
    <meta name="description"
        content="A physics-based 2D sailing prototype. Master wind dynamics, points of sail, and tacking.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://seanmccambridge.com/sailing/">
    <meta property="og:title" content="Sailing Prototype - Level 0">
    <meta property="og:description"
        content="A physics-based 2D sailing prototype. Master wind dynamics, points of sail, and tacking.">
    <meta property="og:image" content="https://seanmccambridge.com/sailing/og-image.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://seanmccambridge.com/sailing/">
    <meta property="twitter:title" content="Sailing Prototype - Level 0">
    <meta property="twitter:description"
        content="A physics-based 2D sailing prototype. Master wind dynamics, points of sail, and tacking.">
    <meta property="twitter:image" content="https://seanmccambridge.com/sailing/og-image.png">
    <style>
        :root {
            --sea: #4fc3f7;
            --land: #aed581;
            --beach: #fff59d;
            --ui-bg: rgba(255, 255, 255, 0.85);
            --text: #2c3e50;
            --accent: #e74c3c;
        }

        * {
            box-sizing: border-box;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: var(--sea);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            overscroll-behavior: none;
            /* Prevent pulling to refresh on mobile */
            color: var(--text);
            /* Prevent iOS magnifying glass and selection menu on long press */
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Full Screen Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(79, 195, 247, 0.9);
            z-index: 100;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
        }

        /* Start Screen */
        .title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 0 #2980b9;
            margin-bottom: 2rem;
        }

        .archetype-container {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn-ship {
            background: var(--ui-bg);
            border: 4px solid #fff;
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            text-align: center;
            width: 200px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s;
        }

        .btn-ship:hover {
            transform: translateY(-2px);
        }

        .btn-ship:active {
            transform: translateY(2px);
        }

        .btn-ship span {
            display: block;
            font-size: 0.9rem;
            font-weight: normal;
            color: #555;
            margin-top: 0.5rem;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Wind Indicator */
        #wind-compass {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: var(--ui-bg);
            border: 3px solid #ccc;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #wind-compass-label {
            position: absolute;
            top: 105px;
            left: 60px;
            /* Center of the compass (20px left + 40px radius) */
            transform: translateX(-50%);
            background: var(--ui-bg);
            padding: 6px 14px;
            border-radius: 12px;
            font-weight: 900;
            font-size: 1.1rem;
            color: #2c3e50;
            text-align: center;
        }

        #wind-arrow {
            font-size: 2rem;
            color: #3498db;
            /* Will be rotated by JS */
        }

        /* Trim & Speed Controls Wrapper */
        #right-panel {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        /* Trim Slider */
        #trim-container {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            padding: 20px 10px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #trim-label {
            font-weight: bold;
            margin-bottom: 20px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            writing-mode: vertical-lr;
            direction: rtl;
            width: 30px;
            height: 200px;
            cursor: pointer;
            touch-action: none;
            background: transparent;
            outline: none;
        }

        /* Custom Track */
        input[type="range"]::-webkit-slider-runnable-track {
            width: 8px;
            /* For vertical slider, this is the width */
            background: rgba(0, 0, 0, 0.15);
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        input[type="range"]::-moz-range-track {
            width: 8px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* Custom Thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 36px;
            width: 36px;
            border-radius: 50%;
            background: #2ecc71;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            margin-left: -14px;
            /* Center thumb on track (width 36 - 8)/2 */
            cursor: grab;
        }

        input[type="range"]::-moz-range-thumb {
            height: 36px;
            width: 36px;
            border-radius: 50%;
            background: #2ecc71;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border: none;
            cursor: grab;
        }

        input[type="range"]:active::-webkit-slider-thumb {
            background: #27ae60;
            cursor: grabbing;
        }

        input[type="range"]:active::-moz-range-thumb {
            background: #27ae60;
            cursor: grabbing;
        }

        /* Feedback Label */
        #trim-feedback {
            margin-top: 15px;
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--text);
            padding: 4px 8px;
            border-radius: 6px;
            background: #eee;
            width: 80px;
            text-align: center;
        }

        #trim-feedback.warning {
            background: #ffeaa7;
            color: #d35400;
        }

        #trim-feedback.error {
            background: #ff7675;
            color: #fff;
        }

        #trim-feedback.good {
            background: #55efc4;
            color: #00b894;
        }

        #trim-feedback.best {
            background: #74b9ff;
            color: #0984e3;
        }

        #trim-feedback.planing {
            background: #0984e3;
            color: #ffffff;
            font-weight: 800;
        }

        /* Speed Indicator */
        #speed-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--ui-bg);
            padding: 10px 15px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .speed-text {
            font-weight: bold;
            font-size: 1rem;
            color: var(--text);
            margin-left: 8px;
            width: 48px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .speed-bar {
            width: 15px;
            height: 20px;
            background: #ddd;
            border-radius: 3px;
        }

        .speed-bar.active {
            background: #2ecc71;
        }

        /* Minimap */
        #minimap-container {
            position: absolute;
            bottom: 110px;
            left: 20px;
            width: 270px;
            height: 270px;
            background: rgba(255, 255, 255, 0.85);
            /* Clean, frosted paper look */
            border: 4px solid #bdc3c7;
            /* Matches compass */
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            z-index: 5;
        }

        #minimap-canvas {
            width: 270px;
            height: 270px;
        }


        /* Tutorial */
        #tutorial {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--ui-bg);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #3498db;
            text-align: center;
            width: 360px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            pointer-events: auto;
            z-index: 20;
        }

        #tutorial h3 {
            margin: 0 0 10px;
        }

        #tutorial ul {
            text-align: left;
            padding-left: 20px;
            font-size: 0.9rem;
        }

        #btn-close-tut {
            margin-top: 10px;
            padding: 6px 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        /* Device-Specific Display Classes */
        .touch-only {
            display: none;
        }

        .desktop-only {
            display: inline;
        }

        @media (pointer: coarse) {
            .touch-only {
                display: inline;
            }

            .desktop-only {
                display: none;
            }
        }

        /* ---- Mobile / Landscape Optimisations ---- */

        /* Use dynamic viewport height: accounts for Safari browser chrome */
        @supports (height: 100dvh) {

            body,
            html {
                height: 100dvh;
            }
        }

        @media (max-width: 1024px) and (orientation: landscape) {

            /* Wind compass: compact, tight to top-left */
            #wind-compass {
                width: 56px;
                height: 56px;
                top: 8px;
                left: 8px;
            }

            #wind-compass-label {
                top: 69px;
                left: 36px;
                font-size: 0.75rem;
                padding: 3px 7px;
            }

            #wind-arrow {
                font-size: 1.4rem;
            }

            /* Minimap: small, sits below wind label â€” no overlap */
            #minimap-container {
                width: 120px;
                height: 120px;
                bottom: 80px;
                left: 8px;
            }

            #minimap-canvas {
                width: 120px;
                height: 120px;
            }

            /* Trim panel */
            #right-panel {
                right: 8px;
            }

            #trim-container {
                padding: 10px 8px;
            }

            #trim-label {
                margin-bottom: 8px;
                font-size: 0.8rem;
            }

            input[type="range"] {
                height: 100px;
            }

            #trim-feedback {
                margin-top: 6px;
                font-size: 0.78rem;
                width: 64px;
            }

            /* Speed indicator */
            #speed-container {
                bottom: 8px;
                padding: 5px 9px;
            }

            .speed-bar {
                width: 11px;
                height: 15px;
            }

            .speed-text {
                font-size: 0.8rem;
            }

            /* Tutorial */
            #tutorial {
                width: min(88vw, 290px);
                padding: 12px;
                top: 6%;
            }

            #tutorial ul {
                font-size: 0.8rem;
            }
        }

        /* ---- Portrait Mobile Optimisations ---- */
        @media (max-width: 1024px) and (orientation: portrait) {

            /* Top Row */
            #wind-compass {
                width: 60px;
                height: 60px;
                top: 12px;
                left: 12px;
            }

            #wind-compass-label {
                top: 75px;
                left: 40px;
                font-size: 0.8rem;
                padding: 4px 8px;
            }

            #wind-arrow {
                font-size: 1.5rem;
            }

            #minimap-container {
                width: 140px;
                height: 140px;
                top: 12px;
                right: 12px;
                left: auto;
                bottom: auto;
            }

            #minimap-canvas {
                width: 140px;
                height: 140px;
            }

            /* Right Panel Controls (Vertical on the right) */
            #right-panel {
                right: 8px;
                top: 48%;
                /* sits higher to leave bottom right corner free for steering touches */
                transform: translateY(-50%);
                align-items: center;
                left: auto;
                bottom: auto;
            }

            #trim-container {
                flex-direction: column;
                width: auto;
                padding: 12px 8px;
                gap: 8px;
            }

            #trim-label {
                margin-bottom: 2px;
                font-size: 0.8rem;
            }

            input[type="range"] {
                writing-mode: vertical-lr;
                /* Explicitly restate for mobile */
                direction: rtl;
                height: 160px;
                /* shorter than desktop to fit on phone */
                width: 30px;
            }

            #trim-feedback {
                margin-top: 2px;
                font-size: 0.75rem;
                width: 55px;
            }

            /* Speed indicator at bottom center */
            #speed-container {
                bottom: 24px;
                padding: 6px 10px;
            }

            .speed-bar {
                width: 12px;
                height: 16px;
            }

            .speed-text {
                font-size: 0.85rem;
            }

            /* Tutorial */
            #tutorial {
                width: 90vw;
                top: 180px;
                padding: 14px;
            }

            #tutorial ul {
                font-size: 0.82rem;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="canvas"></canvas>

        <div id="hud" class="hidden">
            <div id="wind-compass">
                <div id="wind-arrow">
                    <svg viewBox="0 0 24 24" width="48" height="48" fill="#3498db">
                        <path d="M12 22L8 14H11V2H13V14H16L12 22Z" />
                    </svg>
                </div>
            </div>
            <div id="wind-compass-label">Wind</div>

            <div id="right-panel">
                <div id="trim-container">
                    <div id="trim-label">Trim</div>
                    <input type="range" id="trim-slider" min="0" max="100" value="50">
                    <div id="trim-feedback" class="good">Good</div>
                </div>
            </div>

            <div id="speed-container">
                <div class="speed-bar" id="sb-1"></div>
                <div class="speed-bar" id="sb-2"></div>
                <div class="speed-bar" id="sb-3"></div>
                <div class="speed-bar" id="sb-4"></div>
                <div class="speed-bar" id="sb-5"></div>
                <div class="speed-text" id="speed-text">0.0 kt</div>
            </div>

            <div id="minimap-container">
                <canvas id="minimap-canvas" width="540" height="540"></canvas>
            </div>



            <div id="tutorial">
                <h3>Captain's Basics</h3>
                <ul>
                    <li><b>Steer:</b> <span class="desktop-only">A/D keys or Left/Right arrows.</span><span
                            class="touch-only">Touch left/right sides of the screen.</span></li>
                    <li><b>Trim:</b> <span class="desktop-only">W/S keys or Up/Down arrows.</span><span
                            class="touch-only">Use the Trim Slider.</span></li>
                    <li><span class="desktop-only">Use mouse wheel</span><span class="touch-only">Pinch</span> to zoom
                        in
                        and out.</li>
                    <li>Avoid pointing straight into the wind!</li>
                    <li>Tack (zig-zag) to go upwind.</li>
                    <li>Keep your sails trimmed to go fast.</li>
                </ul>
                <button id="btn-close-tut">Got It</button>
            </div>
        </div>

        <div id="start-screen" class="overlay">
            <div class="title">Broadside</div>
            <div class="archetype-container">
                <button class="btn-ship" id="btn-start">
                    START SAILING
                    <span>Click to weigh anchor</span>
                </button>
            </div>
        </div>

        <!-- iOS: shown only if not in standalone mode -->
        <div id="ios-add-tip"
            style="display:none; margin-top:1rem; padding: 0.7rem 1.1rem; background:rgba(255,255,255,0.85); border: 2px solid #bdc3c7; color: #2c3e50; border-radius:8px; font-size:0.85rem; line-height:1.5; max-width:260px; text-align: left;">
            ðŸ’¡ For true fullscreen on iPhone:<br>
            Tap <strong>Share &#x2197;</strong> &rarr; <strong>Add to Home Screen</strong><br>
            then open the app from your home screen.
        </div>
    </div>

    <script>
        // --- CONSTANTS ---
        const CONFIG = {
            mapRadius: 1500, // Circular safe zone roughly
            islandCount: 12
        };

        // --- GAME STATE ---
        let state = {
            playing: false,
            tutorialOpen: true,
            stuckTimer: 0,
            lastTime: 0,
            trueWind: {
                spd: 200, // "Wind force" pixels per sec sort of scaling
                dir: 0    // Angle (will be random)
            },
            keys: {
                left: false, right: false, up: false, down: false
            },
            cameraZoom: 1.0
        };

        let dolphins = [];
        let boat = {
            x: 0, y: 0,
            vx: 0, vy: 0,
            heading: -Math.PI / 2, // North 
            rudder: 0,  // -1 to 1
            trim: 50,   // 0 to 100

            // Physics Profile (set by archetype)
            mass: 0, dragFwd: 0, dragLat: 0, turnRate: 0, baseDrive: 0, hullSpeed: 0,
            width: 0, length: 0, color: ''
        };

        let islands = [];

        // --- DOM Elements ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const hud = document.getElementById('hud');
        const tutorial = document.getElementById('tutorial');
        const windArrow = document.getElementById('wind-arrow');
        const trimSlider = document.getElementById('trim-slider');
        const trimFeedback = document.getElementById('trim-feedback');
        const speedBars = [
            document.getElementById('sb-1'),
            document.getElementById('sb-2'),
            document.getElementById('sb-3'),
            document.getElementById('sb-4'),
            document.getElementById('sb-5')
        ];
        const speedText = document.getElementById('speed-text');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const mCtx = minimapCanvas.getContext('2d');

        let width, height;

        // --- INITIALIZATION ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            // Handle DPI for crisp rendering
            let dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        function initLevel() {
            // Random true wind direction
            state.trueWind.dir = Math.random() * Math.PI * 2;
            // Arrow â¬‡ starts pointing south. Wind dir=0 means blowing east; rotate so arrow points east = direction wind travels.
            windArrow.style.transform = `rotate(${state.trueWind.dir - Math.PI / 2}rad)`;

            // Set starting heading 90 degrees to the wind (beam reach)
            boat.heading = state.trueWind.dir + Math.PI / 2;
            boat.vx = 0;
            boat.vy = 0;
            boat.trim = 50;

            // Generate map of islands
            islands = [];
            for (let i = 0; i < CONFIG.islandCount; i++) {
                // Ensure no island exactly at 0,0 where we spawn
                let x, y, r, d;
                do {
                    x = (Math.random() - 0.5) * CONFIG.mapRadius * 2;
                    y = (Math.random() - 0.5) * CONFIG.mapRadius * 2;
                    r = 40 + Math.random() * 80;
                    d = Math.hypot(x, y);
                } while (d < 300); // clear radius around spawn

                islands.push({ x, y, r });
            }

            trimSlider.value = boat.trim;
        }

        function startGame(type) {
            startScreen.classList.add('hidden');
            hud.classList.remove('hidden');

            // Small boat handling specs
            boat.mass = 1.0;
            boat.dragFwd = 1.3; // Calibrated so baseDrive (350) maxes out around 270 naturally
            boat.dragLat = 3.0;
            boat.turnRate = 2.2;
            boat.baseDrive = 350;
            boat.hullSpeed = 270; // Max theoretical speed before aggressive exponential drag

            // Medium boat visual specs
            boat.color = '#2ecc71'; // Green
            boat.width = 22;
            boat.length = 50;

            initLevel();
            state.playing = true;
            state.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        // --- Fullscreen & iOS Standalone ---
        let gestureGranted = false;

        function isIOS() {
            return /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        function isStandalone() {
            return window.navigator.standalone === true ||
                window.matchMedia('(display-mode: standalone)').matches;
        }

        function isMobile() {
            return navigator.maxTouchPoints > 0 && window.screen.width <= 1024;
        }

        function requestFS() {
            if (isIOS()) return;   // iOS Safari: requestFullscreen simply doesn't exist
            if (!isMobile()) return; // Desktop: skip fullscreen
            const el = document.documentElement;
            try {
                if (el.requestFullscreen) el.requestFullscreen({ navigationUI: 'hide' });
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            } catch (e) { }
        }

        // Show iOS "Add to Home Screen" tip if on iOS and NOT already standalone
        if (isIOS() && !isStandalone()) {
            document.getElementById('ios-add-tip').style.display = 'block';
        }

        document.getElementById('btn-start').addEventListener('click', () => {
            gestureGranted = true;
            requestFS();
            startGame();
        });

        document.getElementById('btn-close-tut').addEventListener('click', () => {
            tutorial.classList.add('hidden');
            state.tutorialOpen = false;
        });

        // --- INPUT HANDLING ---
        window.addEventListener('keydown', (e) => {
            // Hijack Browser Zoom Shortcuts (CMD +/-/0) to trigger our Native Camera
            if (e.metaKey || e.ctrlKey) {
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    if (state.playing) { state.cameraZoom *= 1.15; state.cameraZoom = Math.max(0.15, Math.min(3.0, state.cameraZoom)); }
                } else if (e.key === '-') {
                    e.preventDefault();
                    if (state.playing) { state.cameraZoom /= 1.15; state.cameraZoom = Math.max(0.15, Math.min(3.0, state.cameraZoom)); }
                } else if (e.key === '0') {
                    e.preventDefault();
                    if (state.playing) { state.cameraZoom = 1.0; }
                }
            } else {
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') state.keys.left = true;
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') state.keys.right = true;
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') state.keys.up = true;
                if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') state.keys.down = true;
            }
        }, { passive: false });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') state.keys.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') state.keys.right = false;
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') state.keys.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') state.keys.down = false;
        });

        // Native Camera Zoom (Scroll / Trackpad)
        window.addEventListener('wheel', (e) => {
            if (state.playing) {
                e.preventDefault(); // Stop ALL browser zooming instantly

                // Exponential geometric scale fixes the "getting stuck when zooming out" math bug
                if (e.deltaY > 0) {
                    state.cameraZoom /= 1.05; // Zoom out
                } else if (e.deltaY < 0) {
                    state.cameraZoom *= 1.05; // Zoom in
                }

                state.cameraZoom = Math.max(0.15, Math.min(3.0, state.cameraZoom));
            }
        }, { passive: false });

        // Pinch-to-Zoom (two-finger touch)
        let pinchStartDist = null;
        let pinchStartZoom = 1.0;

        function getTouchDist(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                pinchStartDist = getTouchDist(e.touches);
                pinchStartZoom = state.cameraZoom;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && pinchStartDist !== null) {
                e.preventDefault();
                const dist = getTouchDist(e.touches);
                const scale = dist / pinchStartDist;
                state.cameraZoom = Math.max(0.2, Math.min(3.0, pinchStartZoom * scale));
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) pinchStartDist = null;
        });

        // Suppress native browser pinch-zoom so it doesn't fight our game zoom
        window.addEventListener('gesturestart', (e) => e.preventDefault());
        window.addEventListener('gesturechange', (e) => e.preventDefault());
        window.addEventListener('gestureend', (e) => e.preventDefault());

        trimSlider.addEventListener('input', (e) => {
            boat.trim = parseInt(e.target.value);
        });

        // Canvas Touch Controls
        // Steering: Touch left half of screen = turn left, touch right half = turn right
        let steerTouchId = null;

        function updateSteering(x) {
            if (x < window.innerWidth / 2) {
                state.keys.left = true;
                state.keys.right = false;
            } else {
                state.keys.right = true;
                state.keys.left = false;
            }
        }

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1 && steerTouchId !== null) {
                // Second finger touched down (e.g. for pinch zoom), cancel steering
                steerTouchId = null;
                state.keys.left = false;
                state.keys.right = false;
            } else if (e.touches.length === 1 && steerTouchId === null) {
                const touch = e.touches[0];
                steerTouchId = touch.identifier;

                updateSteering(touch.clientX);
            }
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            if (steerTouchId === null) return;

            // Failsafe: drop steering if multiple touches are active
            if (e.touches.length > 1) {
                steerTouchId = null;
                state.keys.left = false;
                state.keys.right = false;
                return;
            }

            const touch = Array.from(e.changedTouches).find(t => t.identifier === steerTouchId);
            if (!touch) return;

            // Continually update steering based on which side the finger crosses into
            updateSteering(touch.clientX);
        }, { passive: true });

        function endTouch(e) {
            const touch = Array.from(e.changedTouches).find(t => t.identifier === steerTouchId);
            if (touch) {
                steerTouchId = null;
                state.keys.left = false;
                state.keys.right = false;
            }
        }

        canvas.addEventListener('touchend', endTouch);
        canvas.addEventListener('touchcancel', endTouch);

        // --- HELPER MATH ---
        function angleDiff(a, b) {
            let d = a - b;
            while (d > Math.PI) d -= 2 * Math.PI;
            while (d < -Math.PI) d += 2 * Math.PI;
            return d;
        }

        // --- PHYSICS CALCULATION ---
        function updatePhysics(dt) {
            // Steering input mappings
            if (state.keys.left) boat.rudder = -1;
            else if (state.keys.right) boat.rudder = 1;
            else boat.rudder = 0;

            // Optional keyboard trim
            if (state.keys.up) { boat.trim = Math.min(100, boat.trim + 50 * dt); trimSlider.value = boat.trim; }
            if (state.keys.down) { boat.trim = Math.max(0, boat.trim - 50 * dt); trimSlider.value = boat.trim; }

            // Wind Vectors -> apparent wind
            let twVx = state.trueWind.spd * Math.cos(state.trueWind.dir);
            let twVy = state.trueWind.spd * Math.sin(state.trueWind.dir);

            let awVx = twVx - boat.vx;
            let awVy = twVy - boat.vy;
            let awMag = Math.hypot(awVx, awVy);
            let awDir = Math.atan2(awVy, awVx);

            let relWind = angleDiff(awDir, boat.heading); // Angle between heading and apparent wind [-PI, PI]
            let absRelWind = Math.abs(relWind);
            // absRelWind ~0 = into wind, ~PI = dead downwind

            // Forward speed (negative = moving backward)
            let fwdSpeed = boat.vx * Math.cos(boat.heading) + boat.vy * Math.sin(boat.heading);

            // --- No-go zone with hysteresis ---
            // Enter irons at 165Â° (11/12 * PI), must reach 150Â° (5/6 * PI) to exit.
            // This prevents the boundary oscillation that lets driveForce fire and cancel backForce.
            if (boat.inIrons === undefined) boat.inIrons = false;
            if (!boat.inIrons && absRelWind > (Math.PI * 11 / 12)) {
                boat.inIrons = true;  // Enter irons
            } else if (boat.inIrons && absRelWind < (Math.PI * 5 / 6)) {
                boat.inIrons = false; // Exit irons (must fall further off the wind)
            }
            let inNoGo = boat.inIrons;

            // --- Sail/Boom Angle ---
            // trim=100 â†’ sheet fully out â†’ boom can swing up to 90Â° (PI/2)
            // trim=0   â†’ sheet fully in â†’ boom stays near centerline
            let maxSwing = (boat.trim / 100) * (Math.PI / 2);

            // How far does wind want to push the boom out?
            // absRelWind ~ PI (upwind) â†’ naturalOut ~ 0 (sail luffs amidships)
            // absRelWind ~ 0 (downwind) â†’ naturalOut ~ PI/2 (boom out wide)
            let naturalOut = Math.PI / 2 - (absRelWind - Math.PI / 2);
            naturalOut = Math.max(0, Math.min(naturalOut, Math.PI / 2));

            // Sheet limits how far out boom can go
            let boomOut = Math.min(naturalOut, maxSwing);

            // Side: relWind > 0 means apparent wind comes from port (travels to starboard)
            // â†’ boom goes to STARBOARD (negative angle in canvas since it's drawn on -X axis)
            // relWind < 0 means wind from starboard â†’ boom to PORT (positive angle)
            let targetSailAngle = (relWind >= 0) ? -boomOut : boomOut;

            if (boat.sailAngle === undefined) boat.sailAngle = targetSailAngle;
            let sailDiff = angleDiff(targetSailAngle, boat.sailAngle);
            // Limit boom swing speed so a full 180Â° gybe takes about ~0.75 - 1 seconds
            let maxSwingSpeed = 3.6 * dt;
            let sailMove = sailDiff * 8.0 * dt;
            boat.sailAngle += Math.max(-maxSwingSpeed, Math.min(maxSwingSpeed, sailMove));

            // Billow: always curves away from wind, further leeward.
            // relWind >= 0 (wind from port) -> boom stbd, local +Y is stbd -> bSide = 1
            // relWind < 0 (wind from stbd) -> boom port, local -Y is port -> bSide = -1
            boat.billowSide = (relWind >= 0) ? 1 : -1;

            // --- Best trim for UI feedback ---
            // absRelWind ~ PI = upwind â†’ sheet fully IN (trim=0)
            // absRelWind ~ 0  = downwind â†’ sheet fully OUT (trim=100)
            let bestTrim = (1.0 - absRelWind / Math.PI) * 100;
            let trimError = Math.abs(boat.trim - bestTrim);

            // True Wind Angle for Polar and Planing Checks
            let absTWA = Math.abs(angleDiff(state.trueWind.dir, boat.heading));
            let deg = absTWA * (180 / Math.PI);

            // Planing Mechanic (Beam to Broad Reach: deg is between 20 and 90, which means 90 to 160 off the wind)
            // Hysteresis: as you accelerate, Apparent Wind shifts forward, changing your "Best" trim rapidly.
            // We give a generous +-25 buffer to stay in Planing so the speed shift doesn't instantly cancel your buff.
            let planingTolerance = boat.isPlaning ? 25 : 8;
            if (trimError <= planingTolerance && deg >= 20 && deg <= 90) {
                if (typeof boat.planingTimer === 'undefined') boat.planingTimer = 0;
                boat.planingTimer += dt;
            } else {
                boat.planingTimer = 0;
            }
            boat.isPlaning = boat.planingTimer >= 5.0;

            // UI Feedback
            let feedback = "Good";
            trimFeedback.className = "good";
            if (inNoGo) {
                if (fwdSpeed < 15) {
                    feedback = "In Irons!";
                    trimFeedback.className = "error";
                } else {
                    feedback = "Too close!";
                    trimFeedback.className = "warning";
                }
            } else {
                if (boat.isPlaning) {
                    feedback = "On a plane!";
                    trimFeedback.className = "planing";
                } else if (trimError > 40) {
                    feedback = boat.trim < bestTrim ? "Let out!" : "Sheet in!";
                    trimFeedback.className = "error";
                } else if (trimError > 20) {
                    feedback = boat.trim < bestTrim ? "Let out" : "Sheet in";
                    trimFeedback.className = "warning";
                } else if (trimError <= 8) {
                    feedback = "Best";
                    trimFeedback.className = "best";
                }
            }
            trimFeedback.innerText = feedback;

            // --- Drive Force ---
            let driveForce = 0;
            if (!inNoGo) {
                // Trim efficiency: 1.0 at perfect trim, power falls off noticeably with error
                let eff = Math.max(0.05, 1.0 - (trimError / 60.0));

                // Polar: mapped explicitly using True Wind Angle (TWA) to perfectly hit our targets
                // Convention: 0 = dead downwind, 180 = dead upwind
                let basePower;

                if (deg >= 150) { // 150 - 180 (Close Hauled to Irons)
                    let t = (deg - 150) / 30;
                    basePower = 0.75 - t * 0.45; // 0.75 down to 0.30
                } else if (deg >= 120) { // 120 - 150 (Close Reach to Close Hauled)
                    let t = (deg - 120) / 30;
                    basePower = 0.85 - t * 0.10; // 0.85 down to 0.75
                } else if (deg >= 90) { // 90 - 120 (Beam Reach to Close Reach)
                    let t = (deg - 90) / 30;
                    basePower = 1.00 - t * 0.15; // 1.00 down to 0.85
                } else if (deg >= 60) { // 60 - 90 (Broad Reach to Beam Reach)
                    let t = (deg - 60) / 30;
                    basePower = 0.95 + t * 0.05; // 0.95 up to 1.00
                } else if (deg >= 30) { // 30 - 60
                    let t = (deg - 30) / 30;
                    basePower = 0.90 + t * 0.05; // 0.90 up to 0.95
                } else { // 0 - 30 (Dead Downwind to Broad Reach)
                    let t = deg / 30;
                    basePower = 0.80 + t * 0.10; // 0.80 up to 0.90
                }

                // Lee Helm: sail is boomed out wide, pushing the stern.
                // Reversing the sign makes it properly round UP into the wind (Weather Helm effect)
                let leeHelmStrength = Math.max(0, 1.0 - (deg / 90.0));
                let torque = -Math.sign(relWind) * leeHelmStrength * 0.25 * dt;
                boat.heading += torque;

                // Explicitly NOT using an Apparent Wind multiplier here!
                // Apparent wind natively causes compounding positive-feedback loops upwind.
                // We let True Wind strictly govern drive, forcing the boat to perfectly
                // mirror the TWA performance polar percentages at terminal velocity.
                let trueWindFactor = state.trueWind.spd / 200.0;

                driveForce = boat.baseDrive * trueWindFactor * eff * basePower;

                // Extra massive drive force when planing to ensure we overcome the water resistance 
                // and quickly accelerate up to our new +1.0kt hull speed limit
                if (boat.isPlaning) {
                    driveForce *= 1.6;
                }
            }

            // In-irons: Head to wind
            if (inNoGo) {
                let trueWindFactor = state.trueWind.spd / 200.0;
                let trueRelWindSign = Math.sign(angleDiff(state.trueWind.dir, boat.heading));

                // Aerodynamic drag on the rig. 
                // We scale it back as speed gets higher so you don't hit a wall while tacking,
                // but it always eventually stops you if you're stuck in irons.
                let speedBrake = Math.max(0, 1.0 - (fwdSpeed / 80.0));
                let backForce = boat.baseDrive * (0.1 + 1.1 * speedBrake) * trueWindFactor;
                boat.vx -= (backForce / boat.mass) * Math.cos(boat.heading) * dt;
                boat.vy -= (backForce / boat.mass) * Math.sin(boat.heading) * dt;

                // Weathervaning:
                // If you are tacking with momentum (fwdSpeed > 20), don't interfere.
                // If you stall (fwdSpeed < 20), the wind blows the bow OFF the wind.
                // If you are pointed straight into the eye, you drift backwards straight.
                let trueRelWindAbs = Math.abs(angleDiff(state.trueWind.dir, boat.heading));
                let centerDeadband = Math.max(0, 1.0 - trueRelWindAbs / (Math.PI * 0.08));

                let spinDir = (trueRelWindSign >= 0) ? 1.0 : -1.0; // Blow OFF wind

                // The slower you are, the more the wind grabs the bow. Caps at 1.0 when fwdSpeed <= 0.
                let stallGrip = Math.max(0, Math.min(1.0, 1.0 - (fwdSpeed / 20.0)));

                let autoSpin = spinDir * boat.turnRate * 0.4 * stallGrip * (1.0 - centerDeadband) * dt;

                // If drifting backwards and user is actively steering, let the rudder win over the wind's auto-spin
                if (fwdSpeed < -2 && boat.rudder !== 0) {
                    autoSpin *= 0.1;
                }

                boat.heading += autoSpin;
            }

            // Turning: speed-dependent, sign of fwdSpeed reverses rudder when going backward
            let turnEffectiveness = Math.min(1.0, Math.abs(fwdSpeed) / 60.0) * Math.sign(fwdSpeed);
            if (Math.abs(fwdSpeed) < 2) turnEffectiveness *= 0.1; // very sluggish near zero

            // Calculate base rudder turning
            let rudderTurn = boat.rudder * boat.turnRate * turnEffectiveness * dt;

            // Over-trim Weather Helm
            // If the sail is sheeted in too hard (trim < bestTrim), it creates weather helm.
            // Strong enough to overpower the rudder on a broad reach.
            let overTrimWeatherHelm = 0;
            if (!inNoGo && boat.trim < bestTrim) {
                let overTrimAmount = (bestTrim - boat.trim) / 100.0; // 0.0 to 1.0
                let speedFactor = Math.min(1.0, Math.abs(fwdSpeed) / 40.0);

                // Use True Wind to determine side, because Apparent Wind sign flips rapidly when pinching upwind
                let trueRelWindSign = Math.sign(angleDiff(state.trueWind.dir, boat.heading));

                // We scale it down as we go upwind so it doesn't flutter at the no-go threshold,
                // but keep it full strength (3.5 * dt) on a broad reach to overpower the rudder.
                let upwindFade = (absRelWind > Math.PI / 2) ? Math.max(0.15, 1.0 - (absRelWind - Math.PI / 2) / (Math.PI / 2)) : 1.0;
                overTrimWeatherHelm = -trueRelWindSign * overTrimAmount * speedFactor * upwindFade * 3.5 * dt;
            }

            boat.heading += rudderTurn + overTrimWeatherHelm;

            // Acceleration from drive
            let ax = (driveForce / boat.mass) * Math.cos(boat.heading);
            let ay = (driveForce / boat.mass) * Math.sin(boat.heading);

            boat.vx += ax * dt;
            boat.vy += ay * dt;

            // Hydrodynamic Drag (different for forward vs lateral)
            let fwdX = Math.cos(boat.heading);
            let fwdY = Math.sin(boat.heading);
            let latX = Math.cos(boat.heading + Math.PI / 2);
            let latY = Math.sin(boat.heading + Math.PI / 2);

            // Project velocity
            let vFwd = boat.vx * fwdX + boat.vy * fwdY;
            let vLat = boat.vx * latX + boat.vy * latY;

            // Apply drag (forward: linear; lateral: speed-scaled keel effect)
            vFwd *= Math.max(0, 1.0 - boat.dragFwd * dt);

            // Hull speed limit (aggressive exponential drag on excess speed)
            let currentHullSpeed = boat.hullSpeed || 270;
            if (boat.isPlaning) {
                currentHullSpeed += 40; // 40 px/s is exactly 1.0 kt visual
            }

            if (Math.abs(vFwd) > currentHullSpeed) {
                let excess = Math.abs(vFwd) - currentHullSpeed;
                // Braking force scales heavily with how far over hull speed we are
                let brakingForce = excess * 4.0 * dt;
                vFwd -= Math.sign(vFwd) * Math.min(excess, brakingForce);
            }

            // Keel: at full speed locks lateral slip (ice-skate model); stalls at low speed
            let speedFactor = Math.min(1.0, Math.abs(vFwd) / 60.0);
            let effectiveDragLat = boat.dragLat * (0.5 + 5.5 * speedFactor);
            vLat *= Math.max(0, 1.0 - effectiveDragLat * dt);

            // Reconstruct velocity
            boat.vx = vFwd * fwdX + vLat * latX;
            boat.vy = vFwd * fwdY + vLat * latY;

            // Position update
            boat.x += boat.vx * dt;
            boat.y += boat.vy * dt;

            // --- World Boundary ---
            const BOUNDARY_R = CONFIG.mapRadius * 1.7;
            let distFromCenter = Math.hypot(boat.x, boat.y);
            if (distFromCenter > BOUNDARY_R) {
                let overBy = distFromCenter - BOUNDARY_R;
                let nx = boat.x / distFromCenter;
                let ny = boat.y / distFromCenter;
                // Proportional push back toward center
                boat.vx -= nx * overBy * 1.2 * dt;
                boat.vy -= ny * overBy * 1.2 * dt;
                // Hard clamp so you can't escape entirely
                if (distFromCenter > BOUNDARY_R * 1.15) {
                    boat.x = nx * BOUNDARY_R * 1.15;
                    boat.y = ny * BOUNDARY_R * 1.15;
                    // Dampen velocity toward boundary
                    let vDot = boat.vx * nx + boat.vy * ny;
                    if (vDot > 0) { boat.vx -= nx * vDot; boat.vy -= ny * vDot; }
                }
            }

            // Island Collision
            for (let iso of islands) {
                let dx = boat.x - iso.x;
                let dy = boat.y - iso.y;
                let dist = Math.hypot(dx, dy);
                let minDist = boat.length / 2 + iso.r;
                if (dist < minDist) {
                    // Push out
                    let overlap = minDist - dist;
                    boat.x += (dx / dist) * overlap;
                    boat.y += (dy / dist) * overlap;
                    // Bump
                    boat.vx *= 0.5;
                    boat.vy *= 0.5;
                }
            }

            // Dolphin Rescue (stuck check)
            let speedSq = boat.vx * boat.vx + boat.vy * boat.vy;
            if (speedSq < 25) { // moving very slowly
                state.stuckTimer += dt;
                if (state.stuckTimer > 3.0) {
                    state.stuckTimer = 0;

                    // Find push direction away from nearest obstruction
                    let pushDir = boat.heading;
                    let minDist = Infinity;

                    // Check World Boundary
                    let distToBoundary = BOUNDARY_R - distFromCenter;
                    if (distToBoundary < 100 && distToBoundary < minDist) {
                        minDist = distToBoundary;
                        // Push towards the center of the world
                        pushDir = Math.atan2(-boat.y, -boat.x);
                    }

                    // Check Islands
                    for (let iso of islands) {
                        let dx = boat.x - iso.x;
                        let dy = boat.y - iso.y;
                        let distToIsland = Math.hypot(dx, dy) - (iso.r + boat.length / 2);
                        if (distToIsland < Math.min(100, minDist)) {
                            minDist = distToIsland;
                            // Push away from the center of the island
                            pushDir = Math.atan2(dy, dx);
                        }
                    }

                    // Push boat to unstick
                    boat.vx += Math.cos(pushDir) * 150 + (Math.random() - 0.5) * 30;
                    boat.vy += Math.sin(pushDir) * 150 + (Math.random() - 0.5) * 30;

                    // Also turn the boat in that direction so it can sail away
                    boat.heading = pushDir;

                    // Spawn a rescuing dolphin
                    dolphins.push({
                        x: boat.x,
                        y: boat.y,
                        dir: pushDir + (Math.random() - 0.5) * 0.5,
                        life: 2.0
                    });
                }
            } else {
                state.stuckTimer = 0;
            }

            // Update dolphins
            for (let i = dolphins.length - 1; i >= 0; i--) {
                let d = dolphins[i];
                d.life -= dt;
                d.x += Math.cos(d.dir) * 220 * dt;
                d.y += Math.sin(d.dir) * 220 * dt;
                if (d.life <= 0) dolphins.splice(i, 1);
            }

            // Update Speedometer
            let currentFwdSpeed = Math.abs(boat.vx * Math.cos(boat.heading) + boat.vy * Math.sin(boat.heading));
            let maxExpectedSpeed = boat.hullSpeed || 270;
            let speedRatio = Math.min(1.0, currentFwdSpeed / maxExpectedSpeed);
            let activeBars = Math.round(speedRatio * 5);
            speedBars.forEach((bar, i) => {
                bar.className = i < activeBars ? 'speed-bar active' : 'speed-bar';
            });

            // 270 px/sec roughly scales to a fast monohull max of ~6.75 knots
            let knots = currentFwdSpeed * 0.025;
            speedText.innerText = knots.toFixed(1) + " kt";
        }

        // --- DRAWING ---
        function drawBoat(ctx) {
            ctx.save();
            ctx.translate(boat.x, boat.y);
            ctx.rotate(boat.heading);

            // Hull shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(5, 5, boat.length / 2, boat.width / 2 + 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Hull
            ctx.fillStyle = boat.color;
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(boat.length / 2, 0); // Bow
            ctx.quadraticCurveTo(0, boat.width / 2, -boat.length / 2, boat.width / 2 - 2); // Stern right
            ctx.lineTo(-boat.length / 2, -boat.width / 2 + 2); // Stern left
            ctx.quadraticCurveTo(0, -boat.width / 2, boat.length / 2, 0); // Back to bow
            ctx.fill();
            ctx.stroke();

            // Mast
            ctx.fillStyle = '#7f8c8d';
            let mastX = boat.length * 0.15; // Slightly forward
            ctx.beginPath();
            ctx.arc(mastX, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            // Calculate apparent wind relative to boat for sail visuals
            let twVx = state.trueWind.spd * Math.cos(state.trueWind.dir);
            let twVy = state.trueWind.spd * Math.sin(state.trueWind.dir);
            let awVx = twVx - boat.vx;
            let awVy = twVy - boat.vy;
            let awDir = Math.atan2(awVy, awVx);
            let relWind = angleDiff(awDir, boat.heading);

            ctx.save();
            // Sail rotates around mast
            ctx.translate(mastX, 0);

            // Driven by physics engine calculation
            let sailAngle = boat.sailAngle || 0;

            // Luffing: in no-go zone OR sail over-trimmed (sheeted past the wind)
            let luffing = false;
            let absRelWindDraw = Math.abs(relWind);
            let bestTrimDraw = (1.0 - absRelWindDraw / Math.PI) * 100;
            if (absRelWindDraw > (Math.PI * 11 / 12) || boat.trim > bestTrimDraw + 30) {
                luffing = true;
            }

            if (luffing) {
                sailAngle += (Math.random() - 0.5) * 0.15; // Shake
            }

            ctx.rotate(sailAngle);

            // Boom line
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-boat.length * 0.8, 0);
            ctx.stroke();

            // Canvas Sail Shape
            // After ctx.rotate(sailAngle), local-X is along the boom, local-Y is perpendicular.
            // The boom is already on the leeward side (sailAngle is negative when wind from starboard).
            // billowSide: -1 when wind from starboard, +1 when wind from port.
            // In rotated frame, billowSide * boat.width pushes the curve further leeward. âœ“
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.moveTo(0, 0); // Mast attach
            if (luffing) {
                // Flat/Flapping
                ctx.lineTo(-boat.length * 0.8, 0);
                ctx.lineTo(0, -2);
            } else {
                let bSide = boat.billowSide || 1;
                // Control point: midway along boom, pushed out by bSide in local-Y
                ctx.quadraticCurveTo(-boat.length * 0.45, bSide * boat.width * 1.2, -boat.length * 0.8, 0);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore(); // Mast
            ctx.restore(); // Boat
        }

        function drawGame() {
            // Camera tracking
            ctx.fillStyle = "#4fc3f7"; // --sea
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            // Center camera on screen
            ctx.translate(width / 2, height / 2);
            // Apply physical zoom level
            ctx.scale(state.cameraZoom, state.cameraZoom);
            // Translate to boat position
            ctx.translate(-boat.x, -boat.y);

            // Draw Boundary Ring (edge of the known world)
            const BOUNDARY_R = CONFIG.mapRadius * 1.7;
            ctx.save();
            ctx.setLineDash([20, 12]);
            ctx.strokeStyle = 'rgba(180, 60, 60, 0.35)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, BOUNDARY_R, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            // Soft red fog at the edges
            let edgeGrad = ctx.createRadialGradient(0, 0, BOUNDARY_R * 0.75, 0, 0, BOUNDARY_R * 1.1);
            edgeGrad.addColorStop(0, 'rgba(180,60,60,0)');
            edgeGrad.addColorStop(1, 'rgba(180,60,60,0.18)');
            ctx.fillStyle = edgeGrad;
            ctx.beginPath();
            ctx.arc(0, 0, BOUNDARY_R * 1.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Draw Islands
            for (let iso of islands) {
                // Beach
                ctx.fillStyle = "#fff59d"; // --beach
                ctx.beginPath();
                ctx.arc(iso.x, iso.y, iso.r + 8, 0, Math.PI * 2);
                ctx.fill();

                // Grass
                ctx.fillStyle = "#aed581"; // --land
                ctx.beginPath();
                ctx.arc(iso.x, iso.y, iso.r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Wake trailing
            let currentSpeed = Math.abs(boat.vx) + Math.abs(boat.vy);
            if (currentSpeed > 10) {
                let wakeSize = Math.max(2, Math.min(14, currentSpeed / 12));
                ctx.fillStyle = "rgba(255, 255, 255, 0.35)";
                ctx.beginPath();
                let sternX = boat.x - Math.cos(boat.heading) * boat.length / 2;
                let sternY = boat.y - Math.sin(boat.heading) * boat.length / 2;
                ctx.arc(sternX, sternY, wakeSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw Dolphins
            for (let d of dolphins) {
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.dir);
                // Leap effect: 0 at start/end, 1 at peak of jump (life goes 2.0 -> 0.0)
                let leap = 1.0 - Math.abs(d.life - 1.0);
                let scale = 1.0 + leap * 0.4;

                ctx.scale(scale, scale);
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 15 * leap;
                ctx.shadowOffsetY = 15 * leap;

                ctx.fillStyle = '#8395a7'; // dolphin color
                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, 16, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                // Dorsal fin
                ctx.beginPath();
                ctx.moveTo(3, -5); ctx.lineTo(-5, -5); ctx.lineTo(0, -14);
                ctx.fill();
                // Tail
                ctx.beginPath();
                ctx.moveTo(-13, 0); ctx.lineTo(-21, -8); ctx.lineTo(-21, 8);
                ctx.fill();

                ctx.restore();
            }

            drawBoat(ctx);

            ctx.restore();
        }

        // --- MINIMAP ---
        function drawMinimap() {
            // Internal canvas is 540x540 for high dpi
            mCtx.clearRect(0, 0, 540, 540);
            mCtx.save();
            mCtx.translate(270, 270); // Center

            const BOUNDARY_R = CONFIG.mapRadius * 1.7;
            // The edge of the minimap container *is* the world boundary
            const scale = 270 / BOUNDARY_R;
            mCtx.scale(scale, scale);

            // Water tint
            mCtx.beginPath();
            mCtx.arc(0, 0, BOUNDARY_R, 0, Math.PI * 2);
            mCtx.fillStyle = 'rgba(79, 195, 247, 0.15)'; // Very faint blue over the white bg
            mCtx.fill();

            // Islands
            for (let iso of islands) {
                mCtx.fillStyle = '#aed581';
                mCtx.beginPath();
                mCtx.arc(iso.x, iso.y, iso.r, 0, Math.PI * 2);
                mCtx.fill();

                mCtx.lineWidth = 2 / scale;
                mCtx.strokeStyle = '#8bc34a';
                mCtx.stroke();
            }

            // Boat (GPS-style triangle)
            mCtx.fillStyle = '#ff4757'; // High-vis red
            mCtx.save();
            mCtx.translate(boat.x, boat.y);
            mCtx.rotate(boat.heading);
            mCtx.beginPath();
            mCtx.moveTo(24 / scale, 0); // Bow (front apex)
            mCtx.lineTo(-15 / scale, 12 / scale); // Stern (port corner)
            mCtx.lineTo(-15 / scale, -12 / scale); // Stern (starboard corner)
            mCtx.closePath();
            mCtx.fill();
            mCtx.restore();

            mCtx.restore();
        }

        // --- GAME LOOP ---
        function gameLoop(time) {
            if (!state.playing) return;

            let dt = (time - state.lastTime) / 1000;
            state.lastTime = time;

            // Limit dt to prevent huge jumps if tab was inactive
            if (dt > 0.1) dt = 0.1;

            if (!state.tutorialOpen) {
                updatePhysics(dt);
            }
            drawGame();
            drawMinimap();

            requestAnimationFrame(gameLoop);
        }

        // Background decorative draw for start screen
        function idleDraw() {
            if (!state.playing) {
                ctx.fillStyle = "#4fc3f7"; // --sea
                ctx.fillRect(0, 0, width, height);
                // Draw some dummy waves
                ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
                let t = performance.now() / 1000.0;
                for (let i = 0; i < 20; i++) {
                    let wx = (Math.sin(t + i) * 100 + i * 100) % width;
                    let wy = (Math.cos(t * 0.8 + i) * 50 + i * 80) % height;
                    if (wx < 0) wx += width; if (wy < 0) wy += height;
                    ctx.beginPath();
                    ctx.ellipse(wx, wy, 20, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                requestAnimationFrame(idleDraw);
            }
        }
        idleDraw();

    </script>
</body>

</html>