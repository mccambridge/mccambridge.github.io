<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Sailing Prototype - Level 0</title>

    <!-- PWA / iOS Standalone -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Sailing">
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Primary Meta Tags -->
    <meta name="title" content="Sailing Prototype - Level 0">
    <meta name="description"
        content="A physics-based 2D sailing prototype. Master wind dynamics, points of sail, and tacking.">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://seanmccambridge.com/sailing/">
    <meta property="og:title" content="Sailing Prototype - Level 0">
    <meta property="og:description"
        content="A physics-based 2D sailing prototype. Master wind dynamics, points of sail, and tacking.">
    <meta property="og:image" content="https://seanmccambridge.com/sailing/og-image.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://seanmccambridge.com/sailing/">
    <meta property="twitter:title" content="Sailing Prototype - Level 0">
    <meta property="twitter:description"
        content="A physics-based 2D sailing prototype. Master wind dynamics, points of sail, and tacking.">
    <meta property="twitter:image" content="https://seanmccambridge.com/sailing/og-image.png">
    <style>
        :root {
            --sea: #4fc3f7;
            --land: #aed581;
            --beach: #fff59d;
            --ui-bg: rgba(255, 255, 255, 0.85);
            --text: #2c3e50;
            --accent: #e74c3c;
        }

        * {
            box-sizing: border-box;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: var(--sea);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            overscroll-behavior: none;
            /* Prevent pulling to refresh on mobile */
            color: var(--text);
            /* Prevent iOS magnifying glass and selection menu on long press */
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Full Screen Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(79, 195, 247, 0.9);
            z-index: 100;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
        }

        /* Start Screen */
        .title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 0 #2980b9;
            margin-bottom: 2rem;
        }

        .archetype-container {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn-ship {
            background: var(--ui-bg);
            border: 4px solid #fff;
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            text-align: center;
            width: 200px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s;
        }

        .btn-ship:hover {
            transform: translateY(-2px);
        }

        .btn-ship:active {
            transform: translateY(2px);
        }

        .btn-ship span {
            display: block;
            font-size: 0.9rem;
            font-weight: normal;
            color: #555;
            margin-top: 0.5rem;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #debug-net-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ff00;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
        }

        /* Wind Indicator */
        #wind-compass {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 80px;
            height: 80px;
            background: var(--ui-bg);
            border: 3px solid #ccc;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #wind-compass-label {
            position: absolute;
            top: 105px;
            left: 60px;
            /* Center of the compass (20px left + 40px radius) */
            transform: translateX(-50%);
            background: var(--ui-bg);
            padding: 6px 14px;
            border-radius: 12px;
            font-weight: 900;
            font-size: 1.1rem;
            color: #2c3e50;
            text-align: center;
        }

        #wind-arrow {
            font-size: 2rem;
            color: #3498db;
            /* Will be rotated by JS */
        }

        /* Trim & Speed Controls Wrapper */
        #right-panel {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }

        /* Trim Slider */
        #trim-container {
            background: rgba(255, 255, 255, 0.65);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
            padding: 20px 10px;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        #trim-label {
            font-weight: bold;
            margin-bottom: 20px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            writing-mode: vertical-lr;
            direction: rtl;
            width: 30px;
            height: 200px;
            cursor: pointer;
            touch-action: none;
            background: transparent;
            outline: none;
        }

        /* Custom Track */
        input[type="range"]::-webkit-slider-runnable-track {
            width: 8px;
            /* For vertical slider, this is the width */
            background: rgba(0, 0, 0, 0.15);
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        input[type="range"]::-moz-range-track {
            width: 8px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* Custom Thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 36px;
            width: 36px;
            border-radius: 50%;
            background: #2ecc71;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            margin-left: -14px;
            /* Center thumb on track (width 36 - 8)/2 */
            cursor: grab;
        }

        input[type="range"]::-moz-range-thumb {
            height: 36px;
            width: 36px;
            border-radius: 50%;
            background: #2ecc71;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border: none;
            cursor: grab;
        }

        input[type="range"]:active::-webkit-slider-thumb {
            background: #27ae60;
            cursor: grabbing;
        }

        input[type="range"]:active::-moz-range-thumb {
            background: #27ae60;
            cursor: grabbing;
        }

        /* Feedback Label */
        #trim-feedback {
            margin-top: 15px;
            font-weight: bold;
            font-size: 0.9rem;
            color: var(--text);
            padding: 4px 8px;
            border-radius: 6px;
            background: #eee;
            width: 80px;
            text-align: center;
        }

        #trim-feedback.warning {
            background: #ffeaa7;
            color: #d35400;
        }

        #trim-feedback.error {
            background: #ff7675;
            color: #fff;
        }

        #trim-feedback.good {
            background: #55efc4;
            color: #00b894;
        }

        #trim-feedback.best {
            background: #74b9ff;
            color: #0984e3;
        }

        #trim-feedback.planing {
            background: #0984e3;
            color: #ffffff;
            font-weight: 800;
        }

        /* Speed Indicator */
        #speed-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--ui-bg);
            padding: 10px 15px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .speed-text {
            font-weight: bold;
            font-size: 1rem;
            color: var(--text);
            margin-left: 8px;
            width: 48px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .speed-bar {
            width: 15px;
            height: 20px;
            background: #ddd;
            border-radius: 3px;
        }

        .speed-bar.active {
            background: #2ecc71;
        }

        /* Minimap */
        #minimap-container {
            position: absolute;
            bottom: 110px;
            left: 20px;
            width: 270px;
            width: 270px;
            height: 270px;
            background: rgba(255, 255, 255, 0.85);
            /* Clean, frosted paper look */
            border-radius: 50%;
            overflow: hidden;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            pointer-events: none;
            z-index: 5;
        }

        #minimap-canvas {
            width: 270px;
            height: 270px;
        }


        /* Tutorial */
        #tutorial {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--ui-bg);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #3498db;
            text-align: center;
            width: 360px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            pointer-events: auto;
            z-index: 20;
        }

        #tutorial h3 {
            margin: 0 0 10px;
        }

        #tutorial ul {
            text-align: left;
            padding-left: 20px;
            font-size: 0.9rem;
        }

        #btn-close-tut {
            margin-top: 10px;
            padding: 6px 12px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        /* Device-Specific Display Classes */
        .touch-only {
            display: none;
        }

        .desktop-only {
            display: inline;
        }

        @media (pointer: coarse) {
            .touch-only {
                display: inline;
            }

            .desktop-only {
                display: none;
            }
        }

        /* ---- Mobile / Landscape Optimisations ---- */

        /* Use dynamic viewport height: accounts for Safari browser chrome */
        @supports (height: 100dvh) {

            body,
            html {
                height: 100dvh;
            }
        }

        @media (max-width: 1024px) and (orientation: landscape) {

            /* Wind compass: compact, tight to top-left */
            #wind-compass {
                width: 56px;
                height: 56px;
                top: 8px;
                left: 8px;
            }

            #wind-compass-label {
                top: 69px;
                left: 36px;
                font-size: 0.75rem;
                padding: 3px 7px;
            }

            #wind-arrow {
                font-size: 1.4rem;
            }

            /* Minimap: small, sits below wind label â€” no overlap */
            #minimap-container {
                width: 120px;
                height: 120px;
                bottom: 80px;
                left: 8px;
            }

            #minimap-canvas {
                width: 120px;
                height: 120px;
            }

            /* Trim panel */
            #right-panel {
                right: 8px;
            }

            #trim-container {
                padding: 10px 8px;
            }

            #trim-label {
                margin-bottom: 8px;
                font-size: 0.8rem;
            }

            input[type="range"] {
                height: 100px;
            }

            #trim-feedback {
                margin-top: 6px;
                font-size: 0.78rem;
                width: 64px;
            }

            /* Speed indicator */
            #speed-container {
                bottom: 8px;
                padding: 5px 9px;
            }

            .speed-bar {
                width: 11px;
                height: 15px;
            }

            .speed-text {
                font-size: 0.8rem;
            }

            /* Tutorial */
            #tutorial {
                width: min(88vw, 290px);
                padding: 12px;
                top: 6%;
            }

            #tutorial ul {
                font-size: 0.8rem;
            }
        }

        /* ---- Portrait Mobile Optimisations ---- */
        @media (max-width: 1024px) and (orientation: portrait) {

            /* Top Row */
            #wind-compass {
                width: 60px;
                height: 60px;
                top: 12px;
                left: 12px;
            }

            #wind-compass-label {
                top: 75px;
                left: 40px;
                font-size: 0.8rem;
                padding: 4px 8px;
            }

            #wind-arrow {
                font-size: 1.5rem;
            }

            #minimap-container {
                width: 140px;
                height: 140px;
                top: 12px;
                right: 12px;
                left: auto;
                bottom: auto;
            }

            #minimap-canvas {
                width: 140px;
                height: 140px;
            }

            /* Right Panel Controls (Vertical on the right) */
            #right-panel {
                right: 8px;
                top: 48%;
                /* sits higher to leave bottom right corner free for steering touches */
                transform: translateY(-50%);
                align-items: center;
                left: auto;
                bottom: auto;
            }

            #trim-container {
                flex-direction: column;
                width: auto;
                padding: 12px 8px;
                gap: 8px;
            }

            #trim-label {
                margin-bottom: 2px;
                font-size: 0.8rem;
            }

            input[type="range"] {
                writing-mode: vertical-lr;
                /* Explicitly restate for mobile */
                direction: rtl;
                height: 160px;
                /* shorter than desktop to fit on phone */
                width: 30px;
            }

            #trim-feedback {
                margin-top: 2px;
                font-size: 0.75rem;
                width: 55px;
            }

            /* Speed indicator at bottom center */
            #speed-container {
                bottom: 24px;
                padding: 6px 10px;
            }

            .speed-bar {
                width: 12px;
                height: 16px;
            }

            .speed-text {
                font-size: 0.85rem;
            }

            /* Tutorial */
            #tutorial {
                width: 90vw;
                top: 180px;
                padding: 14px;
            }

            #tutorial ul {
                font-size: 0.82rem;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="canvas"></canvas>

        <div id="hud" class="hidden">
            <div id="wind-compass">
                <div id="wind-arrow">
                    <svg viewBox="0 0 24 24" width="48" height="48" fill="#3498db">
                        <path d="M12 22L8 14H11V2H13V14H16L12 22Z" />
                    </svg>
                </div>
            </div>
            <div id="wind-compass-label">Wind</div>

            <div id="right-panel">
                <div id="trim-container">
                    <div id="trim-label">Trim</div>
                    <input type="range" id="trim-slider" min="0" max="100" value="50">
                    <div id="trim-feedback" class="good">Good</div>
                </div>
            </div>

            <div id="speed-container">
                <div class="speed-bar" id="sb-1"></div>
                <div class="speed-bar" id="sb-2"></div>
                <div class="speed-bar" id="sb-3"></div>
                <div class="speed-bar" id="sb-4"></div>
                <div class="speed-bar" id="sb-5"></div>
                <div class="speed-text" id="speed-text">0.0 kt</div>
            </div>

            <div id="minimap-container">
                <canvas id="minimap-canvas" width="540" height="540"></canvas>
            </div>



            <div id="tutorial">
                <h3>Captain's Basics</h3>
                <ul>
                    <li><b>Steer:</b> <span class="desktop-only">A/D keys or Left/Right arrows.</span><span
                            class="touch-only">Touch left/right sides of the screen.</span></li>
                    <li><b>Trim:</b> <span class="desktop-only">W/S keys or Up/Down arrows.</span><span
                            class="touch-only">Use the Trim Slider.</span></li>
                    <li><span class="desktop-only">Use mouse wheel</span><span class="touch-only">Pinch</span> to zoom
                        in
                        and out.</li>
                    <li>Avoid pointing straight into the wind!</li>
                    <li>Tack (zig-zag) to go upwind.</li>
                    <li>Keep your sails trimmed to go fast.</li>
                </ul>
                <button id="btn-close-tut">Got It</button>
            </div>
        </div>

        <div id="start-screen" class="overlay">
            <div class="title">Broadside</div>
            <div class="archetype-container">
                <input type="text" id="player-name" placeholder="Enter Player Name" maxlength="16"
                    style="margin-bottom: 20px; font-size: 1.2rem; padding: 10px; text-align: center; border-radius: 8px; border: 2px solid #2c3e50; width: 100%; max-width: 300px; box-sizing: border-box; background: rgba(255,255,255,0.9);" />
                <div style="display: flex; gap: 10px; width: 100%; justify-content: center;">
                    <button class="btn-ship" id="btn-free">Free Sail<span>No scoring</span></button>
                    <button class="btn-ship" id="btn-race">Race Mode<span>Timed course</span></button>
                </div>
            </div>
        </div>

        <!-- iOS: shown only if not in standalone mode -->
        <div id="ios-add-tip"
            style="display:none; margin-top:1rem; padding: 0.7rem 1.1rem; background:rgba(255,255,255,0.85); border: 2px solid #bdc3c7; color: #2c3e50; border-radius:8px; font-size:0.85rem; line-height:1.5; max-width:260px; text-align: left;">
            ðŸ’¡ For true fullscreen on iPhone:<br>
            Tap <strong>Share &#x2197;</strong> &rarr; <strong>Add to Home Screen</strong><br>
            then open the app from your home screen.
        </div>
    </div>

    <script type="module">
        import PartySocket from "https://esm.sh/partysocket";

        // --- CONSTANTS ---
        const CONFIG = {
            mapRadius: 1500, // Circular safe zone roughly
            islandCount: 12
        };

        // --- GAME STATE ---
        let state = {
            playing: false,
            tutorialOpen: true,
            stuckTimer: 0,
            lastTime: 0,
            trueWind: {
                spd: 200,
                dir: 0
            },
            keys: {
                left: false, right: false, up: false, down: false
            },
            cameraZoom: 1.0,
            serverTick: 0
        };

        let dolphins = [];

        // --- MULTIPLAYER STATE ---
        let socket = null;
        let myBoatId = null;
        let netBoats = new Map(); // string -> interpolated visual BoatState
        let playersById = {}; // string -> { name, boatId, joinedAt }
        let islands = [];
        let snapshots = []; // Buffer for interpolation
        let timeOffset = null; // Syncs precise server physics ticks to local performance.now()
        let currentTrim = 500; // 0 to 1000
        let currentRudder = 0; // -127 to 127
        let inputInterval = null;

        // --- DOM Elements ---
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const playerNameInput = document.getElementById('player-name');
        const btnFree = document.getElementById('btn-free');
        const btnRace = document.getElementById('btn-race');
        const hud = document.getElementById('hud');
        const tutorial = document.getElementById('tutorial');
        const windArrow = document.getElementById('wind-arrow');
        const trimSlider = document.getElementById('trim-slider');
        const trimFeedback = document.getElementById('trim-feedback');
        const speedBars = [
            document.getElementById('sb-1'),
            document.getElementById('sb-2'),
            document.getElementById('sb-3'),
            document.getElementById('sb-4'),
            document.getElementById('sb-5')
        ];
        const speedText = document.getElementById('speed-text');
        const minimapCanvas = document.getElementById('minimap-canvas');
        const mCtx = minimapCanvas.getContext('2d');

        // --- DEBUG NET ---
        const debugPing = document.getElementById('debug-ping');
        const debugTicks = document.getElementById('debug-ticks');
        const debugBuffer = document.getElementById('debug-buffer');
        let lastSnapTime = 0;
        let avgSnapGap = 100;

        let width, height;

        // --- INITIALIZATION ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            // Handle DPI for crisp rendering
            let dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        }
        window.addEventListener('resize', resize);
        resize();

        function initMultiplayer(mode, playerName) {
            // Assume server is running at port 1999 for local dev (localhost or LAN IPs)
            const isLocal = window.location.hostname === "localhost" ||
                window.location.hostname === "127.0.0.1" ||
                window.location.hostname.startsWith("192.168.") ||
                window.location.hostname.startsWith("10.");

            const host = isLocal ? `${window.location.hostname}:1999` : 'broadside-server.mccambridge.partykit.dev';

            const roomName = `broadside-${mode}-v0`;

            socket = new PartySocket({
                host: host,
                room: roomName
            });

            socket.addEventListener("open", () => {
                socket.send(JSON.stringify({
                    type: "hello",
                    name: playerName,
                    archetype: "small"
                }));
            });

            socket.addEventListener("message", (e) => {
                const msg = JSON.parse(e.data);

                if (msg.type === "welcome" || msg.type === "session_reset") {
                    console.log("[Network] Joined session config:", msg);
                    if (msg.type === "welcome") myBoatId = msg.playerId;

                    state.serverTick = msg.serverTick;
                    if (msg.islands) islands = msg.islands;

                    if (msg.windDir !== undefined) {
                        state.trueWind.dir = msg.windDir;
                        state.trueWind.spd = msg.windSpeed;
                    }
                    windArrow.style.transform = `rotate(${state.trueWind.dir - Math.PI / 2}rad)`;

                    // Clear buffer on reset
                    if (msg.type === "session_reset") {
                        snapshots = [];
                        netBoats.clear();
                        timeOffset = null;
                    }
                }
                else if (msg.type === "players_full") {
                    playersById = msg.playersById || {};
                }
                else if (msg.type === "players_diff") {
                    if (msg.join) Object.assign(playersById, msg.join);
                    if (msg.update) Object.assign(playersById, msg.update);
                    if (msg.leave) msg.leave.forEach(id => delete playersById[id]);
                }
                else if (msg.type === "snapshot") {
                    state.serverTick = msg.data.serverTick;

                    let serverTime = msg.data.serverTick * 50; // Server ticks at exactly 20Hz (50ms)
                    let localTime = performance.now();

                    if (timeOffset === null) {
                        timeOffset = localTime - serverTime;
                    } else {
                        // Gently drift the offset toward reality to account for long-term physics clock vs CPU clock skew
                        let currentOffset = localTime - serverTime;
                        timeOffset += (currentOffset - timeOffset) * 0.05;
                    }

                    snapshots.push({
                        time: serverTime + timeOffset,
                        data: msg.data
                    });

                    // Keep buffer small (approx ~500ms at 10Hz)
                    if (snapshots.length > 5) snapshots.shift();

                    // Debug UI updates
                    let now = performance.now();
                    if (lastSnapTime !== 0) {
                        avgSnapGap = avgSnapGap * 0.9 + (now - lastSnapTime) * 0.1;
                    }
                    lastSnapTime = now;

                    if (debugPing) {
                        debugPing.innerText = Math.round(avgSnapGap);
                        debugTicks.innerText = msg.data.serverTick;
                        debugBuffer.innerText = snapshots.length;
                    }
                }
            });

            // Fixed 20Hz Input Pump
            if (inputInterval) clearInterval(inputInterval);
            inputInterval = setInterval(() => {
                if (!state.playing || !myBoatId || !socket) return;

                // Derive integer inputs from keys
                currentRudder = 0;
                if (state.keys.left) currentRudder = -127;
                else if (state.keys.right) currentRudder = 127;

                // Keyboard Trim Fallback
                if (state.keys.up) { currentTrim = Math.min(1000, currentTrim + 50); trimSlider.value = Math.round(currentTrim / 10); }
                if (state.keys.down) { currentTrim = Math.max(0, currentTrim - 50); trimSlider.value = Math.round(currentTrim / 10); }

                socket.send(JSON.stringify({
                    type: "input",
                    seq: Math.floor(performance.now() / 50),
                    rudder: currentRudder,
                    trim: currentTrim
                }));
            }, 50);
        }

        function startGame(mode) {
            gestureGranted = true;
            requestFS();

            const playerName = playerNameInput.value.trim();
            startScreen.classList.add('hidden');
            hud.classList.remove('hidden');

            initMultiplayer(mode, playerName);

            state.playing = true;
            state.lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        btnFree.addEventListener('click', () => startGame('free-sail'));
        btnRace.addEventListener('click', () => startGame('racing'));

        // --- Fullscreen & iOS Standalone ---
        let gestureGranted = false;

        function isIOS() {
            return /iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        function isStandalone() {
            return window.navigator.standalone === true ||
                window.matchMedia('(display-mode: standalone)').matches;
        }

        function isMobile() {
            return navigator.maxTouchPoints > 0 && window.screen.width <= 1024;
        }

        function requestFS() {
            if (isIOS()) return;   // iOS Safari: requestFullscreen simply doesn't exist
            if (!isMobile()) return; // Desktop: skip fullscreen
            const el = document.documentElement;
            try {
                if (el.requestFullscreen) el.requestFullscreen({ navigationUI: 'hide' });
                else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            } catch (e) { }
        }

        // Show iOS "Add to Home Screen" tip if on iOS and NOT already standalone
        if (isIOS() && !isStandalone()) {
            document.getElementById('ios-add-tip').style.display = 'block';
        }

        document.getElementById('btn-close-tut').addEventListener('click', () => {
            tutorial.classList.add('hidden');
            state.tutorialOpen = false;
        });

        // --- INPUT HANDLING ---
        window.addEventListener('keydown', (e) => {
            // Hijack Browser Zoom Shortcuts (CMD +/-/0) to trigger our Native Camera
            if (e.metaKey || e.ctrlKey) {
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    if (state.playing) { state.cameraZoom *= 1.15; state.cameraZoom = Math.max(0.15, Math.min(3.0, state.cameraZoom)); }
                } else if (e.key === '-') {
                    e.preventDefault();
                    if (state.playing) { state.cameraZoom /= 1.15; state.cameraZoom = Math.max(0.15, Math.min(3.0, state.cameraZoom)); }
                } else if (e.key === '0') {
                    e.preventDefault();
                    if (state.playing) { state.cameraZoom = 1.0; }
                }
            } else {
                if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') state.keys.left = true;
                if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') state.keys.right = true;
                if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') state.keys.up = true;
                if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') state.keys.down = true;
            }
        }, { passive: false });
        window.addEventListener('keyup', (e) => {
            if (e.key === 'a' || e.key === 'A' || e.key === 'ArrowLeft') state.keys.left = false;
            if (e.key === 'd' || e.key === 'D' || e.key === 'ArrowRight') state.keys.right = false;
            if (e.key === 'w' || e.key === 'W' || e.key === 'ArrowUp') state.keys.up = false;
            if (e.key === 's' || e.key === 'S' || e.key === 'ArrowDown') state.keys.down = false;
        });

        // Native Camera Zoom (Scroll / Trackpad)
        window.addEventListener('wheel', (e) => {
            if (state.playing) {
                e.preventDefault(); // Stop ALL browser zooming instantly

                // Exponential geometric scale fixes the "getting stuck when zooming out" math bug
                if (e.deltaY > 0) {
                    state.cameraZoom /= 1.05; // Zoom out
                } else if (e.deltaY < 0) {
                    state.cameraZoom *= 1.05; // Zoom in
                }

                state.cameraZoom = Math.max(0.15, Math.min(3.0, state.cameraZoom));
            }
        }, { passive: false });

        // Pinch-to-Zoom (two-finger touch)
        let pinchStartDist = null;
        let pinchStartZoom = 1.0;

        function getTouchDist(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                e.preventDefault();
                pinchStartDist = getTouchDist(e.touches);
                pinchStartZoom = state.cameraZoom;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && pinchStartDist !== null) {
                e.preventDefault();
                const dist = getTouchDist(e.touches);
                const scale = dist / pinchStartDist;
                state.cameraZoom = Math.max(0.2, Math.min(3.0, pinchStartZoom * scale));
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length < 2) pinchStartDist = null;
        });

        // Suppress native browser pinch-zoom so it doesn't fight our game zoom
        window.addEventListener('gesturestart', (e) => e.preventDefault());
        window.addEventListener('gesturechange', (e) => e.preventDefault());
        window.addEventListener('gestureend', (e) => e.preventDefault());

        trimSlider.addEventListener('input', (e) => {
            currentTrim = parseInt(e.target.value) * 10;
        });

        // Canvas Touch Controls
        // Steering: Touch left half of screen = turn left, touch right half = turn right
        let steerTouchId = null;

        function updateSteering(x) {
            if (x < window.innerWidth / 2) {
                state.keys.left = true;
                state.keys.right = false;
            } else {
                state.keys.right = true;
                state.keys.left = false;
            }
        }

        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1 && steerTouchId !== null) {
                // Second finger touched down (e.g. for pinch zoom), cancel steering
                steerTouchId = null;
                state.keys.left = false;
                state.keys.right = false;
            } else if (e.touches.length === 1 && steerTouchId === null) {
                const touch = e.touches[0];
                steerTouchId = touch.identifier;

                updateSteering(touch.clientX);
            }
        }, { passive: true });

        canvas.addEventListener('touchmove', (e) => {
            if (steerTouchId === null) return;

            // Failsafe: drop steering if multiple touches are active
            if (e.touches.length > 1) {
                steerTouchId = null;
                state.keys.left = false;
                state.keys.right = false;
                return;
            }

            const touch = Array.from(e.changedTouches).find(t => t.identifier === steerTouchId);
            if (!touch) return;

            // Continually update steering based on which side the finger crosses into
            updateSteering(touch.clientX);
        }, { passive: true });

        function endTouch(e) {
            const touch = Array.from(e.changedTouches).find(t => t.identifier === steerTouchId);
            if (touch) {
                steerTouchId = null;
                state.keys.left = false;
                state.keys.right = false;
            }
        }

        canvas.addEventListener('touchend', endTouch);
        canvas.addEventListener('touchcancel', endTouch);

        // --- HELPER MATH ---
        function angleDiff(a, b) {
            let d = a - b;
            while (d > Math.PI) d -= 2 * Math.PI;
            while (d < -Math.PI) d += 2 * Math.PI;
            return d;
        }

        // --- INTERPOLATION & VISUALS ---
        function updateInterpolation(time, dt) {
            // Update dolphins
            for (let i = dolphins.length - 1; i >= 0; i--) {
                let d = dolphins[i];
                d.life -= dt;
                d.x += Math.cos(d.dir) * 220 * dt;
                d.y += Math.sin(d.dir) * 220 * dt;
                if (d.life <= 0) dolphins.splice(i, 1);
            }

            if (snapshots.length < 2) return;

            // Assuming 100ms broadcasting (10Hz) and we want ~120ms rendering delay 
            // so we always have a past and future snapshot to lerp between
            const renderTime = performance.now() - 120;

            // Find bounding snapshots
            let snap0 = snapshots[0];
            let snap1 = snapshots[1];
            for (let i = 1; i < snapshots.length; i++) {
                if (snapshots[i].time > renderTime) {
                    snap0 = snapshots[i - 1];
                    snap1 = snapshots[i];
                    break;
                }
            }
            if (!snap1) { snap1 = snapshots[snapshots.length - 1]; snap0 = snap1; }

            let lerpFactor = 0;
            if (snap1.time > snap0.time) {
                lerpFactor = (renderTime - snap0.time) / (snap1.time - snap0.time);
                lerpFactor = Math.max(0, Math.min(1, lerpFactor));
            }

            const activeIds = new Set();

            for (const sBoat of snap1.data.boats) {
                activeIds.add(sBoat.id);

                // Find matching boat in snap0
                const sBoat0 = snap0.data.boats.find(b => b.id === sBoat.id) || sBoat;

                let b = netBoats.get(sBoat.id);
                if (!b) {
                    b = {
                        id: sBoat.id,
                        x: sBoat.x / 10, y: sBoat.y / 10,
                        vx: sBoat.vx / 10, vy: sBoat.vy / 10,
                        heading: (sBoat.heading / 65535) * Math.PI * 2,
                        trim: sBoat.trim / 1000,
                        inIrons: false, isPlaning: false, stuckTimer: 0,
                        sailAngle: 0, billowSide: 1, lastDolphinTick: 0,
                        color: sBoat.id === myBoatId ? '#2ecc71' : '#e74c3c', // Red if enemy!
                        width: 22, length: 50
                    };
                    netBoats.set(sBoat.id, b);
                }

                // Lerp Position
                b.x = sBoat0.x / 10 + ((sBoat.x - sBoat0.x) / 10) * lerpFactor;
                b.y = sBoat0.y / 10 + ((sBoat.y - sBoat0.y) / 10) * lerpFactor;

                b.vx = sBoat0.vx / 10 + ((sBoat.vx - sBoat0.vx) / 10) * lerpFactor;
                b.vy = sBoat0.vy / 10 + ((sBoat.vy - sBoat0.vy) / 10) * lerpFactor;

                b.trim = sBoat0.trim / 1000 + ((sBoat.trim - sBoat0.trim) / 1000) * lerpFactor;

                // Lerp heading strictly along shortest path
                const hdg0 = (sBoat0.heading / 65535) * Math.PI * 2;
                const hdg1 = (sBoat.heading / 65535) * Math.PI * 2;
                b.heading = hdg0 + angleDiff(hdg1, hdg0) * lerpFactor;

                // Decode Flags bits (1=irons, 2=planing, 4=stuck)
                b.inIrons = (sBoat.flags & 1) !== 0;
                b.isPlaning = (sBoat.flags & 2) !== 0;

                // Dolphin trigger (only fire once per flagged server tick)
                if ((sBoat.flags & 4) !== 0 && b.lastDolphinTick !== snap1.data.serverTick) {
                    b.lastDolphinTick = snap1.data.serverTick;
                    const count = 3 + Math.floor(Math.random() * 5); // 3 to 7
                    for (let i = 0; i < count; i++) {
                        // Spawn them slightly *in front* of the boat, and make them swim *backwards* towards it, 
                        // so they look like they are pushing it away from the island with their beaks.
                        dolphins.push({
                            x: b.x + Math.cos(b.heading) * 40 + (Math.random() - 0.5) * 40,
                            y: b.y + Math.sin(b.heading) * 40 + (Math.random() - 0.5) * 40,
                            dir: b.heading + Math.PI + (Math.random() - 0.5) * 1.5,
                            life: 1.5 + Math.random() * 1.0
                        });
                    }
                }

                // Visual Sail Swing Math (identical to old updatePhysics)
                let twVx = state.trueWind.spd * Math.cos(state.trueWind.dir);
                let twVy = state.trueWind.spd * Math.sin(state.trueWind.dir);
                let awVx = twVx - b.vx; let awVy = twVy - b.vy;
                let awDir = Math.atan2(awVy, awVx);
                let relWind = angleDiff(awDir, b.heading);
                let absRelWind = Math.abs(relWind);

                let maxSwing = b.trim * (Math.PI / 2);
                let naturalOut = Math.max(0, Math.min(Math.PI / 2 - (absRelWind - Math.PI / 2), Math.PI / 2));
                let boomOut = Math.min(naturalOut, maxSwing);
                let targetSailAngle = (relWind >= 0) ? -boomOut : boomOut;

                let sailDiff = angleDiff(targetSailAngle, b.sailAngle);
                let maxSwingSpeed = 3.6 * dt;
                let sailMove = sailDiff * 8.0 * dt;
                b.sailAngle += Math.max(-maxSwingSpeed, Math.min(maxSwingSpeed, sailMove));
                b.billowSide = (relWind >= 0) ? 1 : -1;

                // Active Player HUD Updates
                if (b.id === myBoatId) {
                    let trimError = Math.abs((b.trim * 100) - ((1.0 - absRelWind / Math.PI) * 100));

                    // HUD Setup
                    let feedback = "Good";
                    trimFeedback.className = "good";
                    if (b.inIrons) {
                        feedback = "In Irons!"; trimFeedback.className = "error";
                    } else if (b.isPlaning) {
                        feedback = "On a plane!"; trimFeedback.className = "planing";
                    } else if (trimError > 40) {
                        feedback = b.trim * 100 < ((1.0 - absRelWind / Math.PI) * 100) ? "Let out!" : "Sheet in!"; trimFeedback.className = "error";
                    } else if (trimError > 20) {
                        feedback = b.trim * 100 < ((1.0 - absRelWind / Math.PI) * 100) ? "Let out" : "Sheet in"; trimFeedback.className = "warning";
                    } else if (trimError <= 8) {
                        feedback = "Best"; trimFeedback.className = "best";
                    }
                    trimFeedback.innerText = feedback;

                    let currentFwdSpeed = Math.abs(b.vx * Math.cos(b.heading) + b.vy * Math.sin(b.heading));
                    let speedRatio = Math.min(1.0, currentFwdSpeed / 270);
                    let activeBars = Math.round(speedRatio * 5);
                    speedBars.forEach((bar, i) => bar.className = i < activeBars ? 'speed-bar active' : 'speed-bar');
                    speedText.innerText = (currentFwdSpeed * 0.025).toFixed(1) + " kt";
                }
            }

            // Cleanup stale boats
            for (const key of netBoats.keys()) {
                if (!activeIds.has(key)) netBoats.delete(key);
            }
        }

        // --- DRAWING ---
        function drawBoat(ctx, b) {
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(b.heading);

            // Hull shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.beginPath();
            ctx.ellipse(5, 5, b.length / 2, b.width / 2 + 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Hull
            ctx.fillStyle = b.color;
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(b.length / 2, 0); // Bow
            ctx.quadraticCurveTo(0, b.width / 2, -b.length / 2, b.width / 2 - 2); // Stern right
            ctx.lineTo(-b.length / 2, -b.width / 2 + 2); // Stern left
            ctx.quadraticCurveTo(0, -b.width / 2, b.length / 2, 0); // Back to bow
            ctx.fill();
            ctx.stroke();

            // Mast
            ctx.fillStyle = '#7f8c8d';
            let mastX = b.length * 0.15; // Slightly forward
            ctx.beginPath();
            ctx.arc(mastX, 0, 4, 0, Math.PI * 2);
            ctx.fill();

            // Calculate apparent wind relative to boat for sail visuals
            let twVx = state.trueWind.spd * Math.cos(state.trueWind.dir);
            let twVy = state.trueWind.spd * Math.sin(state.trueWind.dir);
            let awVx = twVx - b.vx;
            let awVy = twVy - b.vy;
            let awDir = Math.atan2(awVy, awVx);
            let relWind = angleDiff(awDir, b.heading);

            ctx.save();
            // Sail rotates around mast
            ctx.translate(mastX, 0);

            // Driven by physics engine calculation
            let sailAngle = b.sailAngle || 0;

            // Luffing: in no-go zone OR sail over-trimmed (sheeted past the wind)
            let luffing = false;
            let absRelWindDraw = Math.abs(relWind);
            let bestTrimDraw = (1.0 - absRelWindDraw / Math.PI) * 100;
            if (absRelWindDraw > (Math.PI * 11 / 12) || (b.trim * 100) > bestTrimDraw + 30) {
                luffing = true;
            }

            if (luffing) {
                sailAngle += (Math.random() - 0.5) * 0.15; // Shake
            }

            ctx.rotate(sailAngle);

            // Boom line
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-b.length * 0.8, 0);
            ctx.stroke();

            // Canvas Sail Shape
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.moveTo(0, 0); // Mast attach
            if (luffing) {
                // Flat/Flapping
                ctx.lineTo(-b.length * 0.8, 0);
                ctx.lineTo(0, -2);
            } else {
                let bSide = b.billowSide || 1;
                // Control point: midway along boom, pushed out by bSide in local-Y
                ctx.quadraticCurveTo(-b.length * 0.45, bSide * b.width * 1.2, -b.length * 0.8, 0);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore(); // Mast
            ctx.restore(); // Boat

            // Draw floating Nameplate
            const pInfo = playersById[b.id];
            if (pInfo && pInfo.name && b.id !== myBoatId) {
                ctx.save();
                ctx.translate(b.x, b.y - b.length / 2 - 25); // Hover above boat
                // Scale nameplate back to 1.0 logic to counter camera zoom so text is readable
                ctx.scale(1 / state.cameraZoom, 1 / state.cameraZoom);

                ctx.font = '12px sans-serif';
                const textW = ctx.measureText(pInfo.name).width;

                // Dark pill background
                ctx.fillStyle = 'rgba(0,0,0,0.55)';
                ctx.beginPath();
                ctx.roundRect(-textW / 2 - 6, -10, textW + 12, 18, 9);
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pInfo.name, 0, 0);
                ctx.restore();
            }
        }

        function drawGame() {
            // Camera tracking
            ctx.fillStyle = "#4fc3f7"; // --sea
            ctx.fillRect(0, 0, width, height);

            ctx.save();
            // Center camera on screen
            ctx.translate(width / 2, height / 2);
            // Apply physical zoom level
            ctx.scale(state.cameraZoom, state.cameraZoom);

            // Translate to active player boat position
            let myBoat = netBoats.get(myBoatId);
            if (myBoat) {
                ctx.translate(-myBoat.x, -myBoat.y);
            }

            // Draw Boundary Ring (edge of the known world)
            const BOUNDARY_R = CONFIG.mapRadius * 1.7;
            ctx.save();
            ctx.setLineDash([20, 12]);
            ctx.strokeStyle = 'rgba(180, 60, 60, 0.35)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(0, 0, BOUNDARY_R, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            // Soft red fog at the edges
            let edgeGrad = ctx.createRadialGradient(0, 0, BOUNDARY_R * 0.75, 0, 0, BOUNDARY_R * 1.1);
            edgeGrad.addColorStop(0, 'rgba(180,60,60,0)');
            edgeGrad.addColorStop(1, 'rgba(180,60,60,0.18)');
            ctx.fillStyle = edgeGrad;
            ctx.beginPath();
            ctx.arc(0, 0, BOUNDARY_R * 1.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Draw Islands
            for (let iso of islands) {
                // Beach
                ctx.fillStyle = "#fff59d"; // --beach
                ctx.beginPath();
                ctx.arc(iso.x, iso.y, iso.r + 8, 0, Math.PI * 2);
                ctx.fill();

                // Grass
                ctx.fillStyle = "#aed581"; // --land
                ctx.beginPath();
                ctx.arc(iso.x, iso.y, iso.r, 0, Math.PI * 2);
                ctx.fill();
            }

            // Wake trailing (all boats)
            for (let b of netBoats.values()) {
                let currentSpeed = Math.abs(b.vx) + Math.abs(b.vy);
                if (currentSpeed > 10) {
                    let wakeSize = Math.max(2, Math.min(14, currentSpeed / 12));
                    ctx.fillStyle = "rgba(255, 255, 255, 0.35)";
                    ctx.beginPath();
                    let sternX = b.x - Math.cos(b.heading) * b.length / 2;
                    let sternY = b.y - Math.sin(b.heading) * b.length / 2;
                    ctx.arc(sternX, sternY, wakeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw Dolphins
            for (let d of dolphins) {
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.rotate(d.dir);
                // Leap effect: 0 at start/end, 1 at peak of jump (life goes 2.0 -> 0.0)
                let leap = 1.0 - Math.abs(d.life - 1.0);
                let scale = 1.0 + leap * 0.4;

                ctx.scale(scale, scale);
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 15 * leap;
                ctx.shadowOffsetY = 15 * leap;

                ctx.fillStyle = '#8395a7'; // dolphin color
                // Body
                ctx.beginPath();
                ctx.ellipse(0, 0, 16, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                // Dorsal fin
                ctx.beginPath();
                ctx.moveTo(3, -5); ctx.lineTo(-5, -5); ctx.lineTo(0, -14);
                ctx.fill();
                // Tail
                ctx.beginPath();
                ctx.moveTo(-13, 0); ctx.lineTo(-21, -8); ctx.lineTo(-21, 8);
                ctx.fill();

                ctx.restore();
            }

            // Draw All Boats
            for (let b of netBoats.values()) {
                drawBoat(ctx, b);
            }

            ctx.restore();
        }

        // --- MINIMAP ---
        function drawMinimap() {
            // Internal canvas is 540x540 for high dpi
            mCtx.clearRect(0, 0, 540, 540);
            mCtx.save();
            mCtx.translate(270, 270); // Center

            const BOUNDARY_R = CONFIG.mapRadius * 1.7;
            // The edge of the minimap container *is* the world boundary.
            // A boat at the boundary draws a triangle projecting exactly 24 canvas pixels outward.
            // To prevent the CSS border-radius clip from eating it, we limit the maximum physical scale to 270 - 25 = 245 pixels.
            const scale = (270 - 25) / BOUNDARY_R;
            mCtx.scale(scale, scale);

            // Water tint
            mCtx.beginPath();
            mCtx.arc(0, 0, BOUNDARY_R, 0, Math.PI * 2);
            mCtx.fillStyle = 'rgba(79, 195, 247, 0.15)'; // Very faint blue over the white bg
            mCtx.fill();

            // Draw the gray outline in the canvas natively so boats can render *above* it
            mCtx.lineWidth = 8 / scale;
            mCtx.strokeStyle = '#bdc3c7';
            mCtx.stroke();

            // Islands
            for (let iso of islands) {
                mCtx.fillStyle = '#aed581';
                mCtx.beginPath();
                mCtx.arc(iso.x, iso.y, iso.r, 0, Math.PI * 2);
                mCtx.fill();

                mCtx.lineWidth = 2 / scale;
                mCtx.strokeStyle = '#8bc34a';
                mCtx.stroke();
            }

            // Boats (GPS-style triangles)
            for (let b of netBoats.values()) {
                mCtx.fillStyle = b.id === myBoatId ? '#2ecc71' : '#ff4757';
                mCtx.save();
                mCtx.translate(b.x, b.y);
                mCtx.rotate(b.heading);
                mCtx.beginPath();
                mCtx.moveTo(24 / scale, 0); // Bow (front apex)
                mCtx.lineTo(-15 / scale, 12 / scale); // Stern (port corner)
                mCtx.lineTo(-15 / scale, -12 / scale); // Stern (starboard corner)
                mCtx.closePath();
                mCtx.fill();
                mCtx.restore();
            }

            mCtx.restore();
        }

        // --- GAME LOOP ---
        function gameLoop(time) {
            if (!state.playing) return;

            let dt = (time - state.lastTime) / 1000;
            state.lastTime = time;

            // Limit dt to prevent huge jumps if tab was inactive
            if (dt > 0.1) dt = 0.1;

            if (!state.tutorialOpen) {
                updateInterpolation(time, dt);
            }
            drawGame();
            drawMinimap();

            requestAnimationFrame(gameLoop);
        }

        // Background decorative draw for start screen
        function idleDraw() {
            if (!state.playing) {
                ctx.fillStyle = "#4fc3f7"; // --sea
                ctx.fillRect(0, 0, width, height);
                // Draw some dummy waves
                ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
                let t = performance.now() / 1000.0;
                for (let i = 0; i < 20; i++) {
                    let wx = (Math.sin(t + i) * 100 + i * 100) % width;
                    let wy = (Math.cos(t * 0.8 + i) * 50 + i * 80) % height;
                    if (wx < 0) wx += width; if (wy < 0) wy += height;
                    ctx.beginPath();
                    ctx.ellipse(wx, wy, 20, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                requestAnimationFrame(idleDraw);
            }
        }
        idleDraw();

    </script>
</body>

</html>